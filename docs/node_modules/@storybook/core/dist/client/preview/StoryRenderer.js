"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StoryRenderer = void 0;

require("regenerator-runtime/runtime");

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _global = require("global");

var _ansiToHtml = _interopRequireDefault(require("ansi-to-html"));

var _coreEvents = _interopRequireDefault(require("@storybook/core-events"));

var _clientLogger = require("@storybook/client-logger");

var _NoDocs = require("./NoDocs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var layouts = {
  centered: {
    margin: 0,
    padding: '1rem',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: '100vh',
    boxSizing: 'border-box'
  },
  fullscreen: {
    margin: 0,
    padding: 0,
    display: 'block',
    justifyContent: 'initial',
    alignItems: 'initial',
    minHeight: 'initial'
  },
  padded: {
    margin: 0,
    padding: '1rem',
    display: 'block',
    justifyContent: 'initial',
    alignItems: 'initial',
    minHeight: 'initial'
  }
};
var classes = {
  MAIN: 'sb-show-main',
  NOPREVIEW: 'sb-show-nopreview',
  ERROR: 'sb-show-errordisplay'
};
var ansiConverter = new _ansiToHtml["default"]({
  escapeXML: true
});
/**
 * StoryRenderer is responsible for rendering the correct story to the screen
 *
 * It is very much concerned with drawing to the screen and will do things like change classes
 * on the body etc.
 */

var StoryRenderer = /*#__PURE__*/function () {
  function StoryRenderer(_ref) {
    var render = _ref.render,
        channel = _ref.channel,
        storyStore = _ref.storyStore;

    _classCallCheck(this, StoryRenderer);

    this.render = void 0;
    this.channel = void 0;
    this.storyStore = void 0;
    this.previousMetadata = void 0;
    this.previousStyles = void 0;
    this.render = render;
    this.channel = channel;
    this.storyStore = storyStore;
    this.setupListeners();
  }

  _createClass(StoryRenderer, [{
    key: "setupListeners",
    value: function setupListeners() {
      var _this = this;

      // Channel can be null in StoryShots
      if (this.channel) {
        this.channel.on(_coreEvents["default"].CURRENT_STORY_WAS_SET, function () {
          return _this.renderCurrentStory(false);
        });
        this.channel.on(_coreEvents["default"].STORY_ARGS_UPDATED, function () {
          return _this.forceReRender();
        });
        this.channel.on(_coreEvents["default"].GLOBALS_UPDATED, function () {
          return _this.forceReRender();
        });
        this.channel.on(_coreEvents["default"].FORCE_RE_RENDER, function () {
          return _this.forceReRender();
        });
      }
    }
  }, {
    key: "forceReRender",
    value: function forceReRender() {
      this.renderCurrentStory(true);
    }
  }, {
    key: "renderCurrentStory",
    value: function renderCurrentStory(forceRender) {
      var _this2 = this;

      var storyStore = this.storyStore;
      var loadError = storyStore.getError();

      if (loadError) {
        this.showErrorDisplay(loadError);
        return;
      }

      var _ref2 = storyStore.getSelection() || {},
          storyId = _ref2.storyId,
          urlViewMode = _ref2.viewMode;

      var data = storyStore.fromId(storyId);

      var _ref3 = data || {},
          kind = _ref3.kind,
          id = _ref3.id,
          _ref3$parameters = _ref3.parameters,
          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters,
          getDecorated = _ref3.getDecorated;

      var docsOnly = parameters.docsOnly,
          layout = parameters.layout;
      var metadata = {
        id: id,
        kind: kind,
        viewMode: docsOnly ? 'docs' : urlViewMode,
        getDecorated: getDecorated
      };
      this.applyLayout(metadata.viewMode === 'docs' ? 'fullscreen' : layout);
      var context = Object.assign(Object.assign({
        id: storyId
      }, data), {}, {
        forceRender: forceRender,
        showMain: function showMain() {
          return _this2.showMain();
        },
        showError: function showError(_ref4) {
          var title = _ref4.title,
              description = _ref4.description;
          return _this2.renderError({
            title: title,
            description: description
          });
        },
        showException: function showException(err) {
          return _this2.renderException(err);
        }
      });
      this.renderStoryIfChanged({
        metadata: metadata,
        context: context
      });
    }
  }, {
    key: "renderStoryIfChanged",
    value: function renderStoryIfChanged(_ref5) {
      var metadata = _ref5.metadata,
          context = _ref5.context;
      var forceRender = context.forceRender,
          name = context.name;
      var previousMetadata = this.previousMetadata,
          storyStore = this.storyStore;
      var storyChanged = !previousMetadata || previousMetadata.id !== metadata.id; // getDecorated is a function that returns a decorated story function. It'll change whenever the story
      // is reloaded into the store, which means the module the story was defined in was HMR-ed.

      var implementationChanged = !previousMetadata || previousMetadata.getDecorated !== metadata.getDecorated;
      var viewModeChanged = !previousMetadata || previousMetadata.viewMode !== metadata.viewMode;
      var kindChanged = !previousMetadata || previousMetadata.kind !== metadata.kind; // Don't re-render the story if nothing has changed to justify it

      if (!forceRender && !storyChanged && !implementationChanged && !viewModeChanged) {
        this.channel.emit(_coreEvents["default"].STORY_UNCHANGED, Object.assign(Object.assign({}, metadata), {}, {
          name: name
        }));
        return;
      } // If we are rendering something new (as opposed to re-rendering the same or first story), emit


      if (previousMetadata && (storyChanged || kindChanged || viewModeChanged)) {
        this.channel.emit(_coreEvents["default"].STORY_CHANGED, metadata.id);
      }

      switch (previousMetadata ? previousMetadata.viewMode : 'story') {
        case 'docs':
          if (kindChanged || viewModeChanged) {
            this.storyStore.cleanHooksForKind(previousMetadata.kind);

            _reactDom["default"].unmountComponentAtNode(_global.document.getElementById('docs-root'));
          }

          break;

        case 'story':
        default:
          if (previousMetadata && (storyChanged || viewModeChanged)) {
            this.storyStore.cleanHooks(previousMetadata.id);

            _reactDom["default"].unmountComponentAtNode(_global.document.getElementById('root'));
          }

      } // Docs view renders into a different root ID to avoid conflicts
      // with the user's view layer. Therefore we need to clean up whenever
      // we transition between view modes


      if (viewModeChanged) {
        switch (metadata.viewMode) {
          case 'docs':
            {
              this.showMain();
              this.showDocs();
              break;
            }

          case 'story':
          default:
            {
              if (previousMetadata) {
                this.showStory();
              }
            }
        }
      } // Given a cleaned up state, render the appropriate view mode


      switch (metadata.viewMode) {
        case 'docs':
          {
            this.renderDocs({
              context: context,
              storyStore: storyStore
            });
            break;
          }

        case 'story':
        default:
          {
            this.renderStory({
              context: context
            });
            break;
          }
      }

      this.previousMetadata = metadata;

      if (!forceRender && metadata.viewMode !== 'docs') {
        _global.document.documentElement.scrollTop = 0;
        _global.document.documentElement.scrollLeft = 0;
      }
    }
  }, {
    key: "applyLayout",
    value: function applyLayout(layout) {
      var styles = layouts[layout] || layouts.padded;

      if (styles !== this.previousStyles) {
        Object.assign(_global.document.body.style, styles || {});
        this.previousStyles = styles;
      }
    }
  }, {
    key: "showErrorDisplay",
    value: function showErrorDisplay(_ref6) {
      var _ref6$message = _ref6.message,
          message = _ref6$message === void 0 ? '' : _ref6$message,
          _ref6$stack = _ref6.stack,
          stack = _ref6$stack === void 0 ? '' : _ref6$stack;
      _global.document.getElementById('error-message').innerHTML = ansiConverter.toHtml(message);
      _global.document.getElementById('error-stack').innerHTML = ansiConverter.toHtml(stack);

      _global.document.body.classList.remove(classes.MAIN);

      _global.document.body.classList.remove(classes.NOPREVIEW);

      _global.document.body.classList.add(classes.ERROR);
    }
  }, {
    key: "showNoPreview",
    value: function showNoPreview() {
      _global.document.body.classList.remove(classes.MAIN);

      _global.document.body.classList.remove(classes.ERROR);

      _global.document.body.classList.add(classes.NOPREVIEW);
    }
  }, {
    key: "showMain",
    value: function showMain() {
      _global.document.body.classList.remove(classes.NOPREVIEW);

      _global.document.body.classList.remove(classes.ERROR);

      _global.document.body.classList.add(classes.MAIN);
    }
  }, {
    key: "showDocs",
    value: function showDocs() {
      _global.document.getElementById('root').setAttribute('hidden', 'true');

      _global.document.getElementById('docs-root').removeAttribute('hidden');
    }
  }, {
    key: "showStory",
    value: function showStory() {
      _global.document.getElementById('docs-root').setAttribute('hidden', 'true');

      _global.document.getElementById('root').removeAttribute('hidden');
    }
  }, {
    key: "renderStory",
    value: function renderStory(_ref7) {
      var _this3 = this;

      var context = _ref7.context,
          _ref7$context = _ref7.context,
          id = _ref7$context.id,
          getDecorated = _ref7$context.getDecorated;

      if (getDecorated) {
        _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return _this3.render(context);

                case 3:
                  _this3.channel.emit(_coreEvents["default"].STORY_RENDERED, id);

                  _context.next = 9;
                  break;

                case 6:
                  _context.prev = 6;
                  _context.t0 = _context["catch"](0);

                  _this3.renderException(_context.t0);

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 6]]);
        }))();
      } else {
        this.showNoPreview();
        this.channel.emit(_coreEvents["default"].STORY_MISSING, id);
      }
    }
  }, {
    key: "renderDocs",
    value: function renderDocs(_ref9) {
      var _this4 = this;

      var context = _ref9.context,
          storyStore = _ref9.storyStore;
      var kind = context.kind,
          parameters = context.parameters,
          id = context.id;

      if (id === '*' || !parameters) {
        return;
      }

      var docs = parameters.docs || {};

      if (docs.page && !docs.container) {
        throw new Error('No `docs.container` set, did you run `addon-docs/preset`?');
      }

      var DocsContainer = docs.container || function (_ref10) {
        var children = _ref10.children;
        return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, children);
      };

      var Page = docs.page || _NoDocs.NoDocs; // Docs context includes the storyStore. Probably it would be better if it didn't but that can be fixed in a later refactor

      _reactDom["default"].render( /*#__PURE__*/_react["default"].createElement(DocsContainer, {
        context: Object.assign({
          storyStore: storyStore
        }, context)
      }, /*#__PURE__*/_react["default"].createElement(Page, null)), _global.document.getElementById('docs-root'), function () {
        return _this4.channel.emit(_coreEvents["default"].DOCS_RENDERED, kind);
      });
    } // renderException is used if we fail to render the story and it is uncaught by the app layer

  }, {
    key: "renderException",
    value: function renderException(err) {
      this.channel.emit(_coreEvents["default"].STORY_THREW_EXCEPTION, err);
      this.showErrorDisplay(err); // Log the stack to the console. So, user could check the source code.

      _clientLogger.logger.error(err);
    } // renderError is used by the various app layers to inform the user they have done something
    // wrong -- for instance returned the wrong thing from a story

  }, {
    key: "renderError",
    value: function renderError(_ref11) {
      var title = _ref11.title,
          description = _ref11.description;
      this.channel.emit(_coreEvents["default"].STORY_ERRORED, {
        title: title,
        description: description
      });
      this.showErrorDisplay({
        message: title,
        stack: description
      });
    }
  }]);

  return StoryRenderer;
}();

exports.StoryRenderer = StoryRenderer;