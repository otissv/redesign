"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.index-of");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.object.values");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDataset = exports.ExpanderContext = exports.collapseDocsOnlyStories = exports.collapseAllStories = void 0;

var _global = require("global");

var _react = _interopRequireWildcard(require("react"));

var _api = require("@storybook/api");

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var collapseAllStories = function collapseAllStories(stories) {
  // keep track of component IDs that have been rewritten to the ID of their first leaf child
  var componentIdToLeafId = {}; // 1) remove all leaves

  var leavesRemoved = Object.values(stories).filter(function (item) {
    return !(item.isLeaf && stories[item.parent].isComponent);
  }); // 2) make all components leaves and rewrite their ID's to the first leaf child

  var componentsFlattened = leavesRemoved.map(function (item) {
    var id = item.id,
        isComponent = item.isComponent,
        isRoot = item.isRoot,
        children = item.children,
        rest = _objectWithoutProperties(item, ["id", "isComponent", "isRoot", "children"]); // this is a folder, so just leave it alone


    if (!isComponent) {
      return item;
    }

    var nonLeafChildren = [];
    var leafChildren = [];
    children.forEach(function (child) {
      return (stories[child].isLeaf ? leafChildren : nonLeafChildren).push(child);
    });

    if (leafChildren.length === 0) {
      return item; // pass through, we'll handle you later
    }

    var leafId = leafChildren[0];
    var component = Object.assign(Object.assign({}, rest), {}, {
      id: leafId,
      kind: stories[leafId].kind,
      isRoot: false,
      isLeaf: true,
      isComponent: true,
      children: []
    });
    componentIdToLeafId[id] = leafId; // this is a component, so it should not have any non-leaf children

    if (nonLeafChildren.length !== 0) {
      throw new Error("Unexpected '".concat(item.id, "': ").concat(JSON.stringify({
        isComponent: isComponent,
        nonLeafChildren: nonLeafChildren
      })));
    }

    return component;
  }); // 3) rewrite all the children as needed

  var childrenRewritten = componentsFlattened.map(function (item) {
    if (item.isLeaf) {
      return item;
    }

    var children = item.children,
        rest = _objectWithoutProperties(item, ["children"]);

    var rewritten = children.map(function (child) {
      return componentIdToLeafId[child] || child;
    });
    return Object.assign({
      children: rewritten
    }, rest);
  });
  var result = {};
  childrenRewritten.forEach(function (item) {
    result[item.id] = item;
  });
  return result;
};

exports.collapseAllStories = collapseAllStories;

var collapseDocsOnlyStories = function collapseDocsOnlyStories(storiesHash) {
  // keep track of component IDs that have been rewritten to the ID of their first leaf child
  var componentIdToLeafId = {};
  var docsOnlyStoriesRemoved = Object.values(storiesHash).filter(function (item) {
    if (item.isLeaf && item.parameters && item.parameters.docsOnly) {
      componentIdToLeafId[item.parent] = item.id;
      return false; // filter it out
    }

    return true;
  });
  var docsOnlyComponentsCollapsed = docsOnlyStoriesRemoved.map(function (item) {
    // collapse docs-only components
    var isComponent = item.isComponent,
        children = item.children,
        id = item.id;

    if (isComponent && children.length === 1) {
      var leafId = componentIdToLeafId[id];

      if (leafId) {
        var collapsed = Object.assign(Object.assign({}, item), {}, {
          id: leafId,
          isLeaf: true,
          children: []
        });
        return collapsed;
      }
    } // update groups


    if (children) {
      var rewritten = children.map(function (child) {
        return componentIdToLeafId[child] || child;
      });
      return Object.assign(Object.assign({}, item), {}, {
        children: rewritten
      });
    } // pass through stories unmodified


    return item;
  });
  var result = {};
  docsOnlyComponentsCollapsed.forEach(function (item) {
    result[item.id] = item;
  });
  return result;
};

exports.collapseDocsOnlyStories = collapseDocsOnlyStories;

var ExpanderContext = _react["default"].createContext({
  setExpanded: function setExpanded() {},
  expandedSet: {}
});

exports.ExpanderContext = ExpanderContext;

var useExpanded = function useExpanded(type, parents, initialFiltered, initialUnfiltered) {
  var expandedSets = {
    filtered: (0, _react.useState)(initialFiltered),
    unfiltered: (0, _react.useState)(initialUnfiltered)
  };

  var _expandedSets$type = _slicedToArray(expandedSets[type], 2),
      state = _expandedSets$type[0],
      setState = _expandedSets$type[1];

  (0, _react.useEffect)(function () {
    expandedSets.filtered[1](initialFiltered);
    expandedSets.unfiltered[1](initialUnfiltered);
  }, [initialFiltered, initialUnfiltered]);
  var set = (0, _react.useMemo)(function () {
    return Object.assign(Object.assign({}, state), parents.reduce(function (acc, item) {
      return Object.assign(Object.assign({}, acc), {}, _defineProperty({}, item.id, true));
    }, {}));
  }, [state, parents]);
  return {
    expandedSet: set,
    setExpanded: setState
  };
};

var useSelected = function useSelected(dataset, storyId) {
  return (0, _react.useMemo)(function () {
    return Object.keys(dataset).reduce(function (acc, k) {
      return Object.assign(acc, _defineProperty({}, k, k === storyId));
    }, {});
  }, [dataset, storyId]);
};

var useFiltered = function useFiltered(dataset, filter, parents, storyId) {
  var extra = (0, _react.useMemo)(function () {
    if (dataset[storyId]) {
      return parents.reduce(function (acc, item) {
        return Object.assign(Object.assign({}, acc), {}, _defineProperty({}, item.id, item));
      }, dataset[storyId] ? _defineProperty({}, storyId, dataset[storyId]) : {});
    }

    return {};
  }, [parents]);
  var filteredSet = (0, _react.useMemo)(function () {
    return filter ? (0, _utils.toFiltered)(dataset, filter) : dataset;
  }, [dataset, filter]);
  return (0, _react.useMemo)(function () {
    return filteredSet[storyId] ? filteredSet : Object.assign(Object.assign({}, extra), filteredSet);
  }, [extra, filteredSet]);
};

var useDataset = function useDataset() {
  var storiesHash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var filter = arguments.length > 1 ? arguments[1] : undefined;
  var storyId = arguments.length > 2 ? arguments[2] : undefined;
  var dataset = (0, _react.useMemo)(function () {
    return _global.DOCS_MODE ? collapseAllStories(storiesHash) : collapseDocsOnlyStories(storiesHash);
  }, [_global.DOCS_MODE, storiesHash]);
  var emptyInitial = (0, _react.useMemo)(function () {
    return {
      filtered: {},
      unfiltered: {}
    };
  }, []);
  var datasetKeys = (0, _react.useMemo)(function () {
    return Object.keys(dataset);
  }, [dataset]);
  var initial = (0, _react.useMemo)(function () {
    if (datasetKeys.length) {
      return Object.keys(dataset).reduce(function (acc, k) {
        acc.filtered[k] = true;
        acc.unfiltered[k] = false;
        return acc;
      }, {
        filtered: {},
        unfiltered: {}
      });
    }

    return emptyInitial;
  }, [dataset]);
  var type = filter.length >= 2 ? 'filtered' : 'unfiltered';
  var parents = (0, _react.useMemo)(function () {
    return (0, _utils.getParents)(storyId, dataset);
  }, [dataset[storyId]]);

  var _useExpanded = useExpanded(type, parents, initial.filtered, initial.unfiltered),
      expandedSet = _useExpanded.expandedSet,
      setExpanded = _useExpanded.setExpanded;

  var selectedSet = useSelected(dataset, storyId);
  var filteredSet = useFiltered(dataset, filter, parents, storyId);
  var length = (0, _react.useMemo)(function () {
    return Object.keys(filteredSet).length;
  }, [filteredSet]);
  var topLevel = (0, _react.useMemo)(function () {
    return Object.values(filteredSet).filter(function (i) {
      return i.depth === 0 && !(0, _api.isRoot)(i) || !(0, _api.isRoot)(i) && (0, _api.isRoot)(filteredSet[i.parent]);
    });
  }, [filteredSet]);
  (0, _react.useEffect)(function () {
    if (type === 'filtered') {
      if (topLevel.length < 18) {
        setExpanded(initial.filtered);
      } else {
        setExpanded(initial.unfiltered);
      }
    }
  }, [filter]);

  var _useMemo = (0, _react.useMemo)(function () {
    return (0, _utils.getMains)(filteredSet).reduce(function (acc, item) {
      return (0, _api.isRoot)(item) ? Object.assign(acc, {
        roots: [].concat(_toConsumableArray(acc.roots), [item])
      }) : Object.assign(acc, {
        others: [].concat(_toConsumableArray(acc.others), [item])
      });
    }, {
      roots: [],
      others: []
    });
  }, [filteredSet]),
      roots = _useMemo.roots,
      others = _useMemo.others;

  return {
    roots: roots,
    others: others,
    length: length,
    dataSet: filteredSet,
    selectedSet: selectedSet,
    expandedSet: expandedSet,
    setExpanded: setExpanded
  };
};

exports.useDataset = useDataset;